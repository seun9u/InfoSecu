# 🧱 C언어 변수와 상수 (Variables & Constants)

## 1. 변수와 상수의 차이

### 1) 변수 (Variable)
* 프로그램 실행 도중 **값이 변할 수 있는** 저장 공간입니다.
* 언제든지 새로운 값을 대입하여 변경할 수 있습니다.

```c
int a;
a = 1;
a = 2;
a = 3;
printf("%d\n", a); // 출력: 3 (마지막에 저장된 값)
```

### 2) 상수 (Constant)
* 프로그램 실행 도중 **값이 변하지 않는** 데이터입니다.
* 값을 변경하려고 하면 **에러(Error)**가 발생합니다.

```c
const int b = 1;
b = 2;  // [에러 발생] 상수는 값을 변경할 수 없음
```

---

## 2. 상수의 종류

### 1) 리터럴 상수 (Literal Constant)
* 이름이 없는 값 그 자체를 의미합니다.
```c
int a = 1;       // 1은 리터럴 상수 (정수형)
float b = 3.14F; // 3.14F는 리터럴 상수 (실수형)
```

### 2) 심볼릭 상수 (Symbolic Constant)
* 이름을 가지고 있는 상수입니다.
* `const` 키워드를 사용하거나 `#define` 매크로를 사용합니다.

---

## 3. 상수의 선언 규칙 (⚠️ 중요)
상수는 **"선언과 동시에 값을 저장(초기화)"**해야 합니다.

* **올바른 예:**
    ```c
    const int NUMBER = 10; // 선언과 동시에 초기화 (OK)
    ```

* **잘못된 예 (에러 발생):**
    ```c
    const int NUMBER; // 선언만 함
    NUMBER = 10;      // 나중에 값을 넣으려 하면 에러 발생
    ```

> **Tip:** `const` (Constant의 약자) 키워드를 변수 앞에 붙이면 해당 변수는 상수가 됩니다.

---

## 실습 코드 (`exam-02-06.c`)

매크로 상수와 `const` 상수의 사용법을 비교하는 예제입니다.

```c
// exam-02-06.c 
#include <stdio.h>

// 매크로 상수 (전처리기에 의해 치환됨)
#define LENGTH 10 
#define true  1
#define false 0

int main()
{
    int number = 3;          // 변수
    const int NUMBER = 5;    // 상수 (const)

    number = 10;             // 변수는 값 변경 가능
    // NUMBER = 10;          // [에러] 상수는 값 변경 불가 (주석 처리됨)

    // 매크로 상수 출력
    printf("%d %d %d\n", LENGTH, true, false); 
    // 출력 결과: 10 1 0

    // 변수와 상수 출력
    printf("%d %d\n", number, NUMBER);  
    // 출력 결과: 10 5

    return 0;
}
```

---

## 4. 정수형의 부호 (Signed vs Unsigned)

C언어의 정수 자료형은 부호(양수/음수)의 유무에 따라 저장 방식과 표현 범위가 달라집니다.

### 1) 부호 비트 (Sign Bit)의 개념
* **Signed (부호 있음):**
    * 최상위 비트(MSB)를 **부호 비트**로 사용합니다. (`0`: 양수, `1`: 음수)
    * 남은 비트로 값을 표현하므로 양수 표현 범위가 줄어드는 대신 음수를 표현할 수 있습니다.
* **Unsigned (부호 없음):**
    * 모든 비트를 데이터 값(절댓값)으로 사용합니다.
    * 음수를 표현할 수 없지만, 양수 표현 범위가 2배로 늘어납니다.

### 2) 자료형별 범위 비교

| 자료형 | 키워드 | 크기 | 표현 범위 | 비고 |
| :--- | :--- | :--- | :--- | :--- |
| **char** | `signed char` | 1 Byte | -128 ~ +127 | 문자 및 작은 정수 |
| **unsigned char** | `unsigned char` | 1 Byte | 0 ~ 255 | 바이너리 데이터 처리 등 |
| **int** | `signed int` | 4 Byte | 약 -21억 ~ +21억 | 기본 정수형 |
| **unsigned int** | `unsigned int` | 4 Byte | 0 ~ 약 42억 | 양수 전용 카운트 등 |

> **참고:** `signed` 키워드는 생략 가능합니다. (예: `int`는 `signed int`와 동일)

---

## 5. 오버플로우(Overflow) 실습

자료형의 범위를 벗어난 값을 저장할 때 발생하는 현상을 확인하는 예제입니다.

### 실습 코드 (`exam-03-01.c`)
```c
// exam-03-01.c 
#include <stdio.h>

int main()
{
    // 10진수 128의 비트 패턴: 1000 0000
    char cnum = 128;            // signed char 범위(-128~127)를 벗어남
    unsigned char u_cnum = 128; // unsigned char 범위(0~255)에 포함됨

    printf("cnum = %d\n", cnum);    
    // 출력: -128 (최상위 비트 1을 부호 비트로 해석)

    printf("u_cnum = %d\n", u_cnum); 
    // 출력: 128 (있는 그대로 양수로 해석)

    return 0;
}
```

### 💡 분석
* **`cnum` (Signed):** 비트 `1000 0000`에서 맨 앞의 `1`을 **음수** 표시로 인식하여 `-128`이 됩니다.
* **`u_cnum` (Unsigned):** 비트 `1000 0000` 전체를 숫자로 인식하여 **128**이 됩니다.

---

## 6. 운영체제별 줄바꿈 문자의 차이
텍스트 파일이나 통신 데이터 처리 시 주의해야 할 사항입니다.

* **Windows:** `\r\n` (CR + LF) - 커서를 앞으로 당기고(`\r`) 줄을 바꿈(`\n`)
* **Linux / Unix:** `\n` (LF) - 줄만 바꿈

---

## 7. 데이터 출력 형식과 GDB 메모리 분석

### 실습 코드 (`exam-04-03.c`)
다양한 서식 지정자를 이용한 출력과 메모리 주소를 확인하는 예제입니다.

```c
// exam-04-03.c 
#include <stdio.h>

int main()
{
    char ch = 'X'; 
    // 'X'의 아스키 코드 값 = 88 (10진수) = 0x58 (16진수)

    // %c: 문자, %d: 10진수, %x: 16진수 소문자
    printf("%c %d %x\n", ch, ch, ch); 
    // 출력: X 88 58

    printf("%p\n", &ch); // %p: 포인터(메모리 주소) 출력

    return 0;
}
```

### 🐞 GDB 메모리 분석
`char`형 변수(1바이트)를 4바이트 단위로 읽었을 때의 현상을 분석합니다.

1. **변수 주소 및 값 확인**
    ```gdb
    (gdb) p &ch
    $1 = 0xffffcf1b "X"
    ```
2. **메모리 검사 (`x/xw`)**
    * `x`: Examine (검사)
    * `/xw`: **H**ex(16진수)로 **W**ord(4바이트) 단위 출력
    ```gdb
    (gdb) x/xw &ch
    0xffffcf1b: 0x4f040058
    ```

### 💡 결과 해석 (`0x4f040058`)
리틀 엔디안 방식 시스템에서의 메모리 구조입니다.
* **`58` (가장 오른쪽):** 변수 `ch`에 저장된 실제 값 ('X').
* **`4f0400` (나머지):** 변수 `ch`에 할당되지 않은 인접 메모리의 **쓰레기 값(Garbage Value)**입니다. `x/xw` 명령어가 강제로 4바이트를 읽어왔기 때문에 함께 출력되었습니다.
