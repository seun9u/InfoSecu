# 💾 비트(Bit), 16진수(Hex), 그리고 GDB 메모리 분석

## 1. 비트와 바이트 기초 (Bit & Byte)
컴퓨터가 데이터를 저장하는 가장 작은 단위는 **비트(Bit)**이며, 8개의 비트가 모여 **1바이트(Byte)**가 됩니다.

### 비트의 범위
* **최솟값 (0)**
```text
+---+---+---+---+---+---+---+---+
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
+---+---+---+---+---+---+---+---+
```
* **최댓값 (255)**
```text
+---+---+---+---+---+---+---+---+
| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
+---+---+---+---+---+---+---+---+
```

---

## 2. 16진수 (Hexadecimal)와 사용 이유

### 16진수란?
0부터 15까지의 수를 한 자리로 표현하는 방식입니다.
* **구성:** `0, 1, 2, ..., 9, a(10), b(11), c(12), d(13), e(14), f(15)`
* **표현 개수:** 총 16개

### GDB에서 2진수 대신 16진수를 쓰는 이유
1. **가독성:** 2진수(`00100001`)는 자릿수가 너무 길어 사람이 한눈에 알아보기 힘듭니다.
2. **매핑의 편리함:** **16진수 숫자 1개는 정확히 4비트(Nibble)와 매칭**됩니다.
    * 1 Byte (8 bit) = 16진수 2자리 (4 bit + 4 bit)

```text
2진수:  0000  0000
         |     |
16진수:  0  ~  F (15)
```

---

## 3. 진법 변환 원리 (Decimal → Binary → Hex)
10진수 숫자가 메모리에 어떻게 16진수로 저장되는지 확인해 봅니다.

### 예제 1: 숫자 33
* **10진수:** 33
* **2진수:** `0010 0001` ($32 + 1$)
* **16진수 변환:**

```text
   (상위 4bit)      (하위 4bit)
      0010             0001
       ↓                ↓
       2                1

👉 결과: 0x21
```

### 예제 2: 숫자 34
* **10진수:** 34
* **2진수:** `0010 0010` ($32 + 2$)
* **16진수 변환:**

```text
   (상위 4bit)      (하위 4bit)
      0010             0010
       ↓                ↓
       2                2

👉 결과: 0x22
```

---

## 4. 실습: GDB를 이용한 변수 분석

### 📝 소스 코드 (`gdb1.c`)
```c
#include <stdio.h>

int main()
{
    int a = 33;
    int b = 34;
    printf("%d %d\n", a, b);
    return 0;
}
```

### ⚙️ 컴파일 및 실행
```bash
# 32비트 모드, 디버깅 정보 포함(-g) 컴파일
$ gcc -m32 -g -o gdbint1 gdbint1.c 

# 실행 결과
$ ./gdbint1
33 34
```

### 🐞 GDB 디버깅 세션
GDB를 통해 실제 메모리에 `33`과 `34`가 어떻게 저장되어 있는지 확인합니다.

```bash
$ gdb -q gdbint1

(gdb) b main          # main 함수에 중단점 설정
(gdb) r               # 프로그램 실행 (Run)

# 소스 코드 진행 (Next)
(gdb) n               # int a = 33; 실행
(gdb) n               # int b = 34; 실행
(gdb) n               # printf... 실행 전

# 변수 값 확인
(gdb) p a
$1 = 33
(gdb) p b
$2 = 34

# 변수의 메모리 주소 확인
(gdb) p &a
$3 = (int *) 0xffffcf18
(gdb) p &b
$4 = (int *) 0xffffcf1c

# 메모리 내부 값 확인 (Hex)
# x/xw : 메모리(x)를 16진수(x) Word(w, 4byte) 단위로 확인

(gdb) x/xw &a
0xffffcf18: 0x00000021   <-- 10진수 33은 16진수 0x21

(gdb) x/xw &b
0xffffcf1c: 0x00000022   <-- 10진수 34는 16진수 0x22

(gdb) c
Continuing.
(gdb) q
```

### 💡 핵심 요약
GDB 출력 결과 `0x00000021`인 이유는?
1. **int형**은 4바이트 크기를 가집니다.
2. 값 **33**은 16진수로 **0x21**입니다.
3. 나머지 상위 바이트는 모두 0으로 채워져 `00 00 00 21`이 됩니다.
