# 🚀 C언어 자료형, 진법, 그리고 GDB 디버깅

## 1. C언어 기본 자료형과 `sizeof`
`sizeof` 연산자를 사용하면 데이터 타입이나 변수의 메모리 크기(Byte 단위)를 알 수 있습니다.

### 문자형 (char)
* **단일 문자:** 1개의 문자 저장
* **문자열:** 문자 배열 사용 (저장할 문자 수 + 1, NULL 문자 포함)

```c
char ch = 'A'; // 'A'를 ch 변수에 저장 (ASCII 65)
printf("ch = %d %c\n", ch, ch); 
// 출력: ch = 65 A
```

### 자료형별 크기 (`sizeof`)
시스템 아키텍처(32bit/64bit)에 따라 `long` 등의 크기는 달라질 수 있습니다.

| 자료형 | 크기 (Byte) | 비고 |
| :--- | :--- | :--- |
| **char** | 1 | 문자형 |
| **short** | 2 | 정수형 |
| **int** | 4 | 정수형 (기본) |
| **long** | 4 or 8 | 32bit 환경: 4byte / 64bit 환경: 8byte |
| **float** | 4 | 실수형 |
| **double** | 8 | 실수형 (기본) |
| **long double** | 16 | 더 정밀한 실수형 |

### 문자열 배열 예시
```c
char message[10] = "Hello!";
printf("message size = %d, content = %s\n", sizeof(message), message);
// 출력: message size = 10, content = Hello!
// "Hello!"는 6글자지만 배열 크기를 10으로 잡았으므로 sizeof는 10 반환
```

---

## 2. 진법 (Number Systems)
컴퓨터 구조를 이해하기 위한 기본 진법입니다.

* **2진수 (Binary):** 0과 1로 표현
* **10진수 (Decimal):** 0 ~ 9
* **16진수 (Hexadecimal):** 0 ~ 9, a, b, c, d, e, f

| 10진수 | 2진수 (4bit) | 16진수 |
| :---: | :---: | :---: |
| 0 | 0000 | 0 |
| 1 | 0001 | 1 |
| 2 | 0010 | 2 |
| 3 | 0011 | 3 |
| ... | ... | ... |
| 10 | 1010 | a |
| 15 | 1111 | f |

---

## 3. 리눅스 32bit 컴파일 환경 설정
64bit 리눅스 환경에서 32bit 프로그램을 개발하고 분석하기 위한 설정입니다.

### 1. 필수 패키지 설치
```bash
sudo apt install -y gcc-multilib g++-multilib libc6-dev-i386
```

### 2. 컴파일 옵션 및 실행
* `-m32`: 32bit 모드로 컴파일
* `-g`: GDB 디버깅 정보를 포함 (소스 코드 레벨 분석 시 필수)
* `-o`: 출력 파일명 지정

```bash
# 컴파일 예시
gcc -m32 -g -o datatype2 datatype2.c

# 실행
./datatype2
```

---

## 4. GDB (GNU Debugger) 명령어
리눅스 표준 디버거 GDB의 기초 명령어입니다.

* **Ctrl + L**: 화면 지우기 (Clean)

| 명령어 | 단축키 | 설명 |
| :--- | :--- | :--- |
| **list** | `l` | 소스 코드를 출력 (컴파일 시 `-g` 옵션 필요) |
| **run** | `r` | 프로그램을 시작 (프로세스 실행) |
| **break main** | `b main` | `main()` 함수에 중단점(Break Point) 설정 |
| **print** | `p` | 변수의 값이나 주소를 출력 |
| **next** | `n` | 다음 줄 실행 (함수 내부로 들어가지 않음) |
| **continue** | `c` | 다음 중단점까지 계속 실행 |
| **quit** | `q` | GDB 종료 |

---

## 5. GDB 메모리 분석

### 변수의 메모리 주소 확인
변수 앞에 `&`를 붙여 메모리 주소를 확인합니다.
> **참고:** **ASLR (Address Space Layout Randomization)** 기법으로 인해 실행할 때마다 주소 공간이 랜덤하게 변경됩니다.

```gdb
(gdb) p &number1
$7 = (int *) 0xffffcf14

(gdb) p &number2
$8 = (int *) 0xffffcf18

(gdb) p &number3
$9 = (int *) 0xffffcf1c
```

### `x` 명령어로 메모리 값 확인하기
메모리(Memory) 내용을 직접 조사(Examine)하는 명령어입니다.

**형식:** `x/xw [주소]`

* **x**: Examine (검사)
* **/**: 구분자
* **x**: Hex (16진수로 출력)
* **w**: Word (4byte 단위로 출력)

```gdb
(gdb) x/xw &number1
0xffffcf14: 0x00000001
```

### 🔍 메모리 저장 구조 분석 (4Byte 정수 예시)
`int`형 변수(4byte)가 메모리에 저장되는 구조입니다. (리틀 엔디안 방식)

**값:** `0x00000001` (16진수)
**주소:** `0xffffcf14` 부터 시작

| 메모리 주소 | 저장된 값 (Byte) | 설명 |
| :--- | :--- | :--- |
| `0xffffcf14` | `01` | 하위 바이트 (LSB) |
| `0xffffcf15` | `00` | |
| `0xffffcf16` | `00` | |
| `0xffffcf17` | `00` | 상위 바이트 (MSB) |

```gdb
# 16진수 비트 구조 (0x00000001)
0000 0000 0000 0000 0000 0000 0000 0001
   ^         ^         ^         ^
+0x17     +0x16     +0x15     +0x14  (주소 오프셋)
```

---

## 6. 배열과 메모리 주소 (Arrays & Memory Analysis)
**"배열의 이름은 곧 메모리 시작 주소이다."**

### 변수 vs 배열 주소 확인
```c
char ch1 = 'A';
char message1[] = "ABCDE";
```

* `&ch1`: 변수 ch1의 주소
* `message1`: 배열의 이름 자체가 주소이므로 `&message1`과 동일

```gdb
(gdb) x/xw &ch1
0x7fffffffdd36: 0x43424141
                     |
                     +-- 0x41: 'A' (char ch1 = 'A')

(gdb) x/xw message1
0x7fffffffdd37: 0x44434241
# 0x41(A), 0x42(B), 0x43(C), 0x44(D) 순서로 저장됨 (리틀 엔디안 표기)
```

### GDB 명령어 옵션 상세 분석
`x` 명령어를 사용하여 메모리를 다양한 형식으로 확인할 수 있습니다.

**명령어 분석: `x/2xw message1`**

```text
x / 2 x w message1
| | | | |    |
| | | | |    +-- message1: 확인하려는 메모리 주소 (배열 이름)
| | | | +-- w: Word (4Byte) 단위 출력
| | | +-- x: Hex (16진수)로 출력
| | +-- 2: 보여줄 개수 (Unit 개수)
| +-- /: 구분자
+-- x: eXamine (메모리 검사 명령어)
```

### 문자열 메모리 저장 구조 ("ABCDE")
`message1` 배열에 저장된 값은 `A(0x41)`, `B(0x42)`, `C(0x43)`, `D(0x44)`, `E(0x45)`, `NULL(0x00)` 순서입니다.

```gdb
(gdb) x/2xw message1
0x7fffffffdd37: 0x44434241  0x41200045
                    |           |
                    |           +-- 0x0045: E(45)와 NULL(00)
                    |               (뒤의 20, 41은 쓰레기 값 또는 다음 변수)
                    |
                    +-- 0x44434241: D(44) C(43) B(42) A(41)
                        (리틀 엔디안으로 인해 역순처럼 보임)
```

* **첫 번째 4바이트 (`0x44434241`):** A, B, C, D (D, C, B, A 순으로 보임)
* **두 번째 4바이트 (`0x0045....`):** E, NULL (문자열의 끝)

### 배열 범위 밖의 메모리 확인 (Garbage Value)
배열의 크기를 넘어서 메모리를 확인하면 **쓰레기 값**이나 다른 변수의 값이 보일 수 있습니다.

```gdb
(gdb) x/4xw message1
0x7fffffffdd25: 0xf0000000  0xfff7fe5a  0x2000007f  0xffffffde
# 의도하지 않은 메모리 영역의 값들
```

---

## 7. 아스키 코드 (ASCII Code)
> **참고:** [위키백과 - ASCII](https://ko.wikipedia.org/wiki/ASCII)

컴퓨터에서 문자를 숫자로 표현하기 위한 표준 인코딩 방식입니다.

| Hex (16진수) | Char (문자) | 설명 |
| :---: | :---: | :--- |
| **0x00** | `NUL` | **Null Character** (문자열의 끝을 의미) |
| **0x20** | `SP` | **Space** (공백 문자) |
| | | |
| **0x30** | `0` | 숫자 0 시작 |
| `...` | `...` | |
| **0x39** | `9` | 숫자 9 끝 |
| | | |
| **0x41** | `A` | 대문자 A 시작 |
| **0x42** | `B` | 대문자 B |
| **0x43** | `C` | 대문자 C |
| | | |
| **0x61** | `a` | 소문자 a 시작 |
| **0x62** | `b` | 소문자 b |
| **0x63** | `c` | 소문자 c |

### 💡 주요 패턴 및 팁
* **숫자 (0~9):** `0x30`부터 시작합니다.
* **대문자 (A~Z):** `0x41`부터 시작합니다.
* **소문자 (a~z):** `0x61`부터 시작합니다.
* **대/소문자 변환:** 대문자와 소문자는 **`0x20` (10진수 32)** 만큼 차이가 납니다.
    * 예: `A` (0x41) + 0x20 = `a` (0x61)

